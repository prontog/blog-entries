---
output:
  md_document:
    variant: markdown_github
---

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
```

During the last couple of years, I've been relearning statistics through various [MOOCs](http://Massive open online course) most of which had assignments in **R**. Soon enough I grew fond of the simplicity of the language, of its powerful interpreter, of its documentation and base library with its many useful functions for importing, analyzing, plotting and exporting data.

As I was exploring the import functions (most of them are named read.*XXX*) I fell across [read.fwf](https://stat.ethz.ch/R-manual/R-devel/library/utils/html/read.fwf.html) that reads files with lines of fixed width format. You just pass it a filename and two vectors, one with the name of the columns and another with the size (in characters) of its column. It returns a data.frame with each line split into columns. Nice! In the company where I work we maintain several text protocols for inter-process communication, and one of them is fixed width. Yoo-Hoo, I could read a log file into R and fool around with it. But wait, I forgot, these logs are more complicated. Each line is fixed width, but the protocol includes different message types each one with different formatting. This means that the log file has lines of different fixed width format and *read.fwf* cannot handle such a file. What I needed was a function capable of handling multiple fixed width formats in a single file. Searching in R's *base* package, [CRAN](https://cran.r-project.org), Github and Google didn't result anything.

I decided to create it myself and try building it around read.fwf since the base package developers have made such a good job with it. After some thought, I arrived at the following design:

1.Split the file according to message type.
2.Read each new file with *read.fwf*.

So instead of passing the *name* and *width* vectors I would pass a *list* of name and width of vectors with each pair specifying a message type. On success, the function would return a *list* of data.frames.

[read.multifwf](http://finzi.psych.upenn.edu/library/multifwf/html/read.multi.fwf.html)(...)

The first implementation was buggy because I optimized prematurely. This optimization had to do with the temp files (from step 1). To write to these files I use the *cat* function for each line read from the whole file. Instead of calling *cat* with the temp filename as parameter *file*, I used *connection objects* (think of it as file descriptors). This meant that I had to use the *open* function to open each temp file, use the *connection* and close it (using the *close* function) before returning. This might sound simple but in reality it wasn't. Although the function returned the correct result, some files were left opened (and were eventually closed by R) while others were closed multiple times (throwing exceptions). After trying to debug this for a while, I gave up and used *cat* with filenames instead of file handles, which solved the problem. On the downside, I measured, a performance drop of around 20% which, to be honest, is fine by me.

The function is available on CRAN in the package [multifwf](https://cran.r-project.org/web/packages/multifwf/index.html). Here's an example on how to use *read.multifwf*:

```{r, example}
library(multifwf)

# Create a temp file with a few lines from a SOP (Simple Order Protocol,
# an imganinary protocol) log file.
ff <- tempfile()
cat(file = ff, 
    '10:15:03:279NOSLMT0000666    EVILCORP00010.77SomeClientId    SomeAccountId   ',
    '10:15:03:793OC000001BLMT0000666    EVILCORP00010.77SomeClientId    SomeAccountId   ',
    '10:17:45:153NOBLMT0000666    EVILCORP00001.10AnotherClientId AnotherAccountId',
    '10:17:45:487RJAnotherClientId 004price out of range                              ',
    '10:18:28:045NOBLMT0000666    EVILCORP00011.00AnotherClientId AnotherAccountId',
    '10:18:28:472OC000002BLMT0000666    EVILCORP00011.00AnotherClientId AnotherAccountId',
    '10:18:28:642TR0000010000010000666    EVILCORP00010.77',
    '10:18:28:687TR0000010000020000666    EVILCORP00010.77', 
    sep = '\n')

# Create a list of specs. Each item contains the specification for
# each message type of this simple protocol.
specs <- list()
specs[['newOrder']] <- data.frame(
    widths = c(12, 2, 1, 3, 7, 12, 8, 16, 16), 
    col.names = c('timestamp', 'msgType', 'side', 'type', 'volume', 
                  'symbol', 'price', 'clientId', 'accountId'))
specs[['orderConf']] <- data.frame(
    widths = c(12, 2, 6, 1, 3, 7, 12, 8, 16, 16), 
    col.names = c('timestamp', 'msgType', 'orderId', 'side', 'type', 
                  'volume', 'symbol', 'price', 'clientId', 'accountId'))

specs[['rejection']] <- data.frame(
    widths = c(12, 2, 16, 3, 48), 
    col.names = c('timestamp', 'msgType', 'clientId', 
                  'rejectionCode', 'text'))

specs[['trade']] <- data.frame(
    widths = c(12, 2, 6, 6, 7, 12, 8), 
    col.names = c('timestamp', 'msgType', 'tradeId', 'orderId', 
                  'volume', 'symbol', 'price'))

# The selector function is responsible for identifying the message type 
# of a line.
myselector <- function(line, specs) {
    s <- substr(line, 13, 14)
    spec_name = ''
    if (s == 'NO')
        spec_name = 'newOrder'
    else if (s == 'OC')
        spec_name = 'orderConf'
    else if (s == 'TR')
        spec_name = 'trade'
    else if (s == 'RJ')
        spec_name = 'rejection'

    spec_name
}

read.multi.fwf(ff, multi.specs = specs, select = myselector)

unlink(ff)
```

You will find the source in [Github](https://github.com/prontog/multifwf).
